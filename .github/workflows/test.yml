name: Run Tagged Tests

on:
  # Trigger manual
  workflow_dispatch:
    inputs:
      test_suite:
        description: 'Suite de tests a ejecutar'
        required: true
        default: 'Smoke General'
        type: choice
        options:
          - 'Smoke General'
          - 'Onboarding v1'
          - 'Onboarding v2'
          - 'Orders v1'
          - 'Orders v2'
          - 'Pagos'
          - 'Billing'
          - 'Top Up'
          - 'Providers'
          - 'Refunds'
          - 'SintÃ©ticos'
          - 'Withdraw Fiat v1'
          - 'Withdraw Fiat v2'
          - 'Withdraw Crypto V1'
          - 'Withdraw Crypto V2'
          - 'Remesas'
          - 'Integrations - OnboardingV2'
          - 'Integrations - Lock Payment'
          - 'Integrations - Withdraw V2'

  # EjecuciÃ³n automÃ¡tica en cada push
  push:
    branches:
      - '**' # Se ejecuta en todas las ramas, o especifica ramas especÃ­ficas como: main, develop, etc.

  # EjecuciÃ³n automÃ¡tica de Providers todos los dÃ­as a las 01:30 AM hora Argentina (03:30 UTC)
  schedule:
    - cron: '30 3 * * *'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set test suite for scheduled run
        id: set-suite
        run: |
          if [ "${{ github.event_name }}" == "schedule" ]; then
            TEST_SUITE="Providers"
            echo "ðŸ• EjecuciÃ³n programada - Suite: Providers"
          elif [ "${{ github.event_name }}" == "push" ]; then
            TEST_SUITE="Onboarding v2"
            echo "ðŸš€ EjecuciÃ³n por push - Suite: Onboarding v2"
          else
            TEST_SUITE="${{ github.event.inputs.test_suite }}"
            echo "ðŸ‘¤ EjecuciÃ³n manual - Suite: $TEST_SUITE"
          fi
          echo "test_suite=${TEST_SUITE}" >> $GITHUB_OUTPUT

      - name: Map test suite to tags
        id: map-tags
        run: |
          case "${{ steps.set-suite.outputs.test_suite }}" in
            "Smoke General")
              TAGS="@Smoke and @Automated"
              ;;
            "Onboarding v1")
              TAGS="@Onboarding and @Smoke and @Automated"
              ;;
            "Onboarding v2")
              TAGS="@OnboardingV2 and @Smoke and @Automated"
              ;;
            "Orders v1")
              TAGS="@Orders and @Smoke and @V1 and @Automated"
              ;;
            "Orders v2")
              TAGS="@Orders and @Smoke and @V2 and @Automated"
              ;;
            "Pagos")
              TAGS="@QR and @Smoke and @Automated"
              ;;
            "Billing")
              TAGS="@Billing and @Smoke and @Automated"
              ;;
            "Top Up")
              TAGS="@Topup and @Smoke and @Automated"
              ;;
            "Providers")
              TAGS="@Provider and @Smoke and @Automated"
              ;;
            "Refunds")
              TAGS="@Refunds and @Manual and @Automated"
              ;;
            "SintÃ©ticos")
              TAGS="@Sintetico and @Smoke and @Automated"
              ;;
            "Withdraw Fiat v1")
              TAGS="@Withdraw and @Smoke and @Fiat and @V1 and @Automated"
              ;;
            "Withdraw Fiat v2")
              TAGS="@Withdraw and @Smoke and @Fiat and @V2 and @Automated"
              ;;
            "Withdraw Crypto V1")
              TAGS="@Withdraw and @Smoke and @Crypto and @V1 and @Automated"
              ;;
            "Withdraw Crypto V2")
              TAGS="@Withdraw and @Smoke and @Crypto and @V2Endpoint and @Automated"
              ;;
            "Remesas")
              TAGS="@Withdraw and @Smoke and @Remesas and @Automated"
              ;;
            "Integrations - OnboardingV2")
              TAGS="@Integrations and @OnboardingV2 and @Regression and @Automated"
              ;;
            "Integrations - Lock Payment")
              TAGS="@Integrations and @LockPayment and @Regression and @Automated"
              ;;            
            "Integrations - Withdraw V2")
              TAGS="@Integrations and @WithdrawV2 and @Regression and @Automated"
              ;;
            *)            
              TAGS="@Smoke and @Automated"
              ;;            
          esac

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ Suite seleccionada: ${{ steps.set-suite.outputs.test_suite }}"
          echo "ðŸ“‹ Tags a ejecutar: ${TAGS}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Verify CodeArtifact connectivity
        run: |
          aws codeartifact describe-repository \
            --domain td \
            --repository backend-shared-libs \
            --region ${{ secrets.AWS_REGION }} \
            --query 'repository.name' \
            --output text

      - name: Configure CodeArtifact authentication
        run: |
          CODEARTIFACT_AUTH_TOKEN=$(aws codeartifact get-authorization-token \
            --domain td \
            --region ${{ secrets.AWS_REGION }} \
            --query authorizationToken \
            --output text)

          CODEARTIFACT_REGISTRY=$(aws codeartifact get-repository-endpoint \
            --domain td \
            --repository backend-shared-libs \
            --format npm \
            --region ${{ secrets.AWS_REGION }} \
            --query repositoryEndpoint \
            --output text)

          echo "registry=${CODEARTIFACT_REGISTRY}" > ~/.npmrc
          echo "${CODEARTIFACT_REGISTRY#https:}:_authToken=${CODEARTIFACT_AUTH_TOKEN}" >> ~/.npmrc
          echo "@md:registry=${CODEARTIFACT_REGISTRY}" >> ~/.npmrc
          echo "fetch-retries=5" >> ~/.npmrc
          echo "fetch-retry-mintimeout=10000" >> ~/.npmrc
          echo "fetch-retry-maxtimeout=60000" >> ~/.npmrc
          echo "fetch-timeout=300000" >> ~/.npmrc

          echo "=== ConfiguraciÃ³n .npmrc ==="
          cat ~/.npmrc

          unset CODEARTIFACT_AUTH_TOKEN

      - name: Install dependencies
        run: npm ci

      - name: Run Cucumber tests - ${{ steps.set-suite.outputs.test_suite }}
        continue-on-error: true
        run: |
          TAGS="${{ steps.map-tags.outputs.tags }}"

          echo "ðŸ·ï¸ Suite: ${{ steps.set-suite.outputs.test_suite }}"
          echo "ðŸ“‹ Ejecutando tests con tags: $TAGS"

          npx cucumber-js --tags "$TAGS" --format json:cucumber-report.json
          node reporter.js

      - name: Generate Test Summary and Prepare Email
        if: always()
        id: test-summary
        run: |
          echo "## ðŸ§ª Resumen de Tests - ${{ steps.set-suite.outputs.test_suite }}" >> $GITHUB_STEP_SUMMARY

          if [ -f cucumber-report.json ]; then
            cat > analyze-results.js << 'EOF'
            const fs = require('fs');
            
            try {
              const report = JSON.parse(fs.readFileSync('cucumber-report.json', 'utf8'));
              
              let totalScenarios = 0;
              let passedScenarios = 0;
              let failedScenarios = 0;
              let totalSteps = 0;
              let passedSteps = 0;
              let failedSteps = 0;
              let skippedSteps = 0;
              let totalDuration = 0;
              
              const failedTests = [];
              
              report.forEach(feature => {
                if (feature.elements) {
                  feature.elements.forEach(scenario => {
                    totalScenarios++;
                    let scenarioFailed = false;
                    let failureDetails = null;
                    
                    if (scenario.steps) {
                      scenario.steps.forEach(step => {
                        totalSteps++;
                        
                        if (step.result) {
                          if (step.result.duration) {
                            totalDuration += step.result.duration;
                          }
                          
                          switch (step.result.status) {
                            case 'passed':
                              passedSteps++;
                              break;
                            case 'failed':
                              failedSteps++;
                              scenarioFailed = true;
                              // Capturar detalles del fallo
                              if (!failureDetails) {
                                failureDetails = {
                                  step: step.name || 'Step sin nombre',
                                  error: step.result.error_message || 'Error sin mensaje'
                                };
                              }
                              break;
                            case 'skipped':
                              skippedSteps++;
                              break;
                          }
                        }
                      });
                    }
                    
                    if (scenarioFailed) {
                      failedScenarios++;
                      failedTests.push({
                        feature: feature.name || 'Feature sin nombre',
                        scenario: scenario.name || 'Escenario sin nombre',
                        failureDetails: failureDetails
                      });
                    } else {
                      passedScenarios++;
                    }
                  });
                }
              });
              
              const duration = Math.round(totalDuration / 1000000);
              const successRate = totalScenarios > 0 ? Math.round((passedScenarios / totalScenarios) * 100) : 0;
              const failureRate = totalScenarios > 0 ? Math.round((failedScenarios / totalScenarios) * 100) : 0;
              
              console.log('| MÃ©trica | Valor |');
              console.log('|---------|-------|');
              console.log(`| ðŸ“Š **Escenarios Totales** | ${totalScenarios} |`);
              console.log(`| âœ… **Escenarios Exitosos** | ${passedScenarios} |`);
              console.log(`| âŒ **Escenarios Fallidos** | ${failedScenarios} |`);
              console.log(`| ðŸ“ˆ **Tasa de Ã‰xito** | ${successRate}% |`);
              console.log(`| ðŸ“‰ **Tasa de Fallo** | ${failureRate}% |`);
              console.log(`| ðŸ”§ **Steps Totales** | ${totalSteps} |`);
              console.log(`| â±ï¸ **DuraciÃ³n Total** | ${duration}ms |`);
              console.log('');
              
              if (failedTests.length > 0) {
                console.log('### âŒ Tests Fallidos:');
                console.log('');
                failedTests.forEach((test, index) => {
                  console.log(`#### ${index + 1}. ${test.feature} â†’ ${test.scenario}`);
                  console.log('');
                  if (test.failureDetails) {
                    console.log('**Step fallido:**');
                    console.log('```');
                    console.log(test.failureDetails.step);
                    console.log('```');
                    console.log('');
                    console.log('**Error:**');
                    console.log('```');
                    // Limitar a las primeras 20 lÃ­neas del error para no saturar el reporte
                    const errorLines = test.failureDetails.error.split('\n').slice(0, 20);
                    console.log(errorLines.join('\n'));
                    if (test.failureDetails.error.split('\n').length > 20) {
                      console.log('... (error truncado, ver reporte completo)');
                    }
                    console.log('```');
                    console.log('');
                  }
                });
              }
              
              if (failedScenarios === 0) {
                console.log('### ðŸŽ‰ Â¡Todos los tests pasaron exitosamente!');
              }
              
              const emailData = {
                testStatus: failedScenarios > 0 ? 'TESTS_FAILED' : 'TESTS_PASSED',
                testSuite: process.env.TEST_SUITE || 'Unknown',
                totalScenarios,
                passedScenarios,
                failedScenarios,
                successRate,
                failureRate,
                totalSteps,
                duration,
                failedTests,
                isCriticalFailure: failureRate > 65,
                timestamp: new Date().toLocaleString('es-ES', { timeZone: 'America/Argentina/Mendoza' })
              };
              
              fs.writeFileSync('test-results.json', JSON.stringify(emailData, null, 2));
                            
            } catch (error) {
              console.log('âŒ Error analizando resultados:', error.message);
              const errorData = {
                testStatus: 'ANALYSIS_ERROR',
                testSuite: process.env.TEST_SUITE || 'Unknown',
                error: error.message,
                isCriticalFailure: false,
                timestamp: new Date().toLocaleString('es-ES', { timeZone: 'America/Argentina/Mendoza' })
              };
              require('fs').writeFileSync('test-results.json', JSON.stringify(errorData, null, 2));
            }
          EOF

            TEST_SUITE="${{ steps.set-suite.outputs.test_suite }}" node analyze-results.js >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ No se encontrÃ³ cucumber-report.json" >> $GITHUB_STEP_SUMMARY
            echo '{"testStatus":"NO_REPORT","testSuite":"${{ steps.set-suite.outputs.test_suite }}","timestamp":"'$(date)'","error":"No se encontrÃ³ cucumber-report.json","isCriticalFailure":false}' > test-results.json
          fi

      - name: Check if email should be sent
        if: always()
        id: check-email
        run: |
          SHOULD_SEND="false"

          if [ -f test-results.json ]; then
            FAILURE_RATE=$(cat test-results.json | grep -o '"failureRate":[0-9]*' | cut -d':' -f2)
            IS_CRITICAL=$(cat test-results.json | grep -o '"isCriticalFailure":[a-z]*' | cut -d':' -f2)
            
            if [ "$IS_CRITICAL" == "true" ] || [ "$FAILURE_RATE" -gt 65 ] 2>/dev/null; then
              SHOULD_SEND="true"
              echo "ðŸ“§ Se enviarÃ¡ correo: Tasa de fallo ${FAILURE_RATE}% supera el 65%"
            else
              echo "ðŸ“­ No se enviarÃ¡ correo: Tasa de fallo ${FAILURE_RATE}% no supera el 65%"
            fi
          else
            echo "âš ï¸ No se encontraron resultados de tests"
          fi

          echo "should_send=${SHOULD_SEND}" >> $GITHUB_OUTPUT

      - name: Create Slack-friendly summary
        if: always()
        id: slack-summary
        run: |
          if [ -f test-results.json ]; then
            cat > create-slack-summary.js << 'EOF'
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('test-results.json', 'utf8'));
            
            let summary = '*ðŸ“Š Resultados de Tests*\n\n';
            
            if (results.testStatus === 'TESTS_PASSED' || results.testStatus === 'TESTS_FAILED') {
              summary += `âœ… *Exitosos:* ${results.passedScenarios}/${results.totalScenarios}\n`;
              summary += `âŒ *Fallidos:* ${results.failedScenarios}\n`;
              summary += `ðŸ“ˆ *Tasa de Ã©xito:* ${results.successRate}%\n`;
              summary += `ðŸ“‰ *Tasa de fallo:* ${results.failureRate}%\n`;
              summary += `â±ï¸ *DuraciÃ³n:* ${results.duration}ms\n\n`;
              
              // Alerta crÃ­tica si tasa de fallo > 65%
              if (results.isCriticalFailure) {
                summary += '*ðŸš¨ ALERTA CRÃTICA: Tasa de fallo superior al 65%*\n\n';
              }
              
              if (results.failedTests && results.failedTests.length > 0) {
                summary += '*âŒ Tests Fallidos:*\n';
                results.failedTests.slice(0, 5).forEach(test => {
                  const scenarioName = test.scenario.replace(/"/g, '\\"');
                  summary += `â€¢ ${scenarioName}\n`;
                });
                if (results.failedTests.length > 5) {
                  summary += `... y ${results.failedTests.length - 5} mÃ¡s\n`;
                }
              } else {
                summary += '*ðŸŽ‰ Â¡Todos los tests pasaron exitosamente!*\n';
              }
            } else {
              summary += `âš ï¸ ${results.error || 'Error al analizar resultados'}\n`;
            }
            
            summary += `\n_Timestamp: ${results.timestamp}_`;
            
            const output = JSON.stringify(summary);
            console.log(output);
          EOF
            
            SUMMARY=$(node create-slack-summary.js)
            echo "summary=${SUMMARY}" >> $GITHUB_OUTPUT
          else
            SUMMARY=$(echo '"âš ï¸ No se generaron resultados de tests"' | jq -r .)
            echo "summary=${SUMMARY}" >> $GITHUB_OUTPUT
          fi

      - name: Determine Workflow Status
        if: always()
        id: workflow-status
        run: |
          WORKFLOW_STATUS="SUCCESS"

          if [ ! -f test-results.json ]; then
            WORKFLOW_STATUS="FAILED"
            echo "âš ï¸ No se generaron resultados de tests"
          else
            TEST_STATUS=$(cat test-results.json | grep -o '"testStatus":"[^"]*' | cut -d'"' -f4)
            if [ "$TEST_STATUS" == "TESTS_FAILED" ] || [ "$TEST_STATUS" == "ANALYSIS_ERROR" ] || [ "$TEST_STATUS" == "NO_REPORT" ]; then
              WORKFLOW_STATUS="FAILED"
            fi
          fi

          echo "workflow_status=${WORKFLOW_STATUS}" >> $GITHUB_OUTPUT
          echo "ðŸ“Š Estado del Workflow: ${WORKFLOW_STATUS}"

      - name: Send Slack Notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SUITE_NAME: ${{ steps.set-suite.outputs.test_suite }}
          WORKFLOW_STATUS: ${{ steps.workflow-status.outputs.workflow_status }}
          EVENT_TYPE: ${{ github.event_name }}
          ACTOR: ${{ github.actor }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SUMMARY: ${{ steps.slack-summary.outputs.summary }}
        run: |
          # Determinar emoji y estilo
          if [ "$WORKFLOW_STATUS" == "SUCCESS" ]; then
            EMOJI="âœ…"
            BUTTON_STYLE="primary"
          else
            EMOJI="âŒ"
            BUTTON_STYLE="danger"
          fi

          # Determinar tipo de ejecuciÃ³n
          if [ "$EVENT_TYPE" == "schedule" ]; then
            EXEC_TYPE="ðŸ• Programado"
          elif [ "$EVENT_TYPE" == "push" ]; then
            EXEC_TYPE="ðŸš€ Push"
          else
            EXEC_TYPE="ðŸ‘¤ Manual"
          fi

          # Procesar el resumen (remover comillas externas si existen)
          CLEAN_SUMMARY=$(echo "$SUMMARY" | sed 's/^"//;s/"$//')

          # Crear payload JSON
          cat > slack-payload.json << EOF
          {
            "text": "$EMOJI Tests $SUITE_NAME",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "$EMOJI Tests: $SUITE_NAME"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Suite:*\\n$SUITE_NAME"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Estado:*\\n$WORKFLOW_STATUS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Tipo:*\\n$EXEC_TYPE"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Ejecutado por:*\\n$ACTOR"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": $SUMMARY
                }
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "ðŸ“Š Ver Detalles Completos"
                    },
                    "url": "$RUN_URL",
                    "style": "$BUTTON_STYLE"
                  }
                ]
              }
            ]
          }
          EOF

          # Enviar a Slack
          curl -X POST -H 'Content-type: application/json' \
            --data @slack-payload.json \
            "$SLACK_WEBHOOK_URL"

      - name: Generate Email Body with Failure Details
        if: always() && steps.check-email.outputs.should_send == 'true'
        id: email-body
        run: |
          cat > generate-email-body.js << 'EOF'
          const fs = require('fs');

          try {
            const results = JSON.parse(fs.readFileSync('test-results.json', 'utf8'));
            
            let body = `ðŸš¨ ALERTA CRÃTICA: TASA DE FALLO SUPERIOR AL 65%\n\n`;
            body += `Hola!\n\n`;
            body += `Se detectÃ³ una tasa de fallo crÃ­tica en la suite "${results.testSuite}".\n\n`;
            body += `ðŸ“Š ESTADÃSTICAS:\n`;
            body += `- Tasa de fallo: ${results.failureRate}%\n`;
            body += `- Escenarios fallidos: ${results.failedScenarios}/${results.totalScenarios}\n`;
            body += `- Escenarios exitosos: ${results.passedScenarios}/${results.totalScenarios}\n`;
            body += `- DuraciÃ³n total: ${results.duration}ms\n\n`;
            
            if (results.failedTests && results.failedTests.length > 0) {
              body += `âŒ DETALLES DE FALLOS:\n\n`;
              
              results.failedTests.forEach((test, index) => {
                body += `${index + 1}. Feature: ${test.feature}\n`;
                body += `   Escenario: ${test.scenario}\n`;
                
                if (test.failureDetails) {
                  body += `   Step fallido: ${test.failureDetails.step}\n`;
                  body += `   Error:\n`;
                  // Limitar el mensaje de error a las primeras lÃ­neas para no saturar el email
                  const errorLines = test.failureDetails.error.split('\n').slice(0, 5);
                  errorLines.forEach(line => {
                    body += `   ${line}\n`;
                  });
                  if (test.failureDetails.error.split('\n').length > 5) {
                    body += `   ... (ver detalles completos en el reporte)\n`;
                  }
                }
                body += `\n`;
              });
            }
            
            body += `---\n`;
            body += `Timestamp: ${results.timestamp}\n`;
            
            // Guardar el cuerpo del email en un archivo
            fs.writeFileSync('email-body.txt', body);
            console.log('Email body generado correctamente');
            
          } catch (error) {
            const fallbackBody = `Error al generar el cuerpo del email: ${error.message}`;
            fs.writeFileSync('email-body.txt', fallbackBody);
            console.error('Error:', error.message);
          }
          EOF

          node generate-email-body.js

      - name: Send Email Notification
        if: always() && steps.check-email.outputs.should_send == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          from: ${{ secrets.EMAIL_USERNAME }}
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          subject: "ðŸš¨ ALERTA CRÃTICA - Tests ${{ steps.set-suite.outputs.test_suite }} - Tasa de Fallo > 65% [${{ steps.workflow-status.outputs.workflow_status || 'FAILED' }}]"
          body: file://email-body.txt
          convert_markdown: true
          attachments: |
            cucumber-report.json
            test-results.json

      - name: Upload report artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cucumber-html-report-${{ steps.set-suite.outputs.test_suite }}-${{ github.run_number }}
          path: |
            cucumber-report.html
            reports/
            cucumber-report.json
            test-results.json
            email-body.txt
